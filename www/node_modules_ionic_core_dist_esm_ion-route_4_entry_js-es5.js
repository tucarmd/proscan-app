(function () {
  "use strict";

  function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }

  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }

  function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }

  function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }

  function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }

  function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }

  function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

  function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }

  function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }

  function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }

  function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }

  function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

  (self["webpackChunkcom_carmd_proscan2"] = self["webpackChunkcom_carmd_proscan2"] || []).push([["node_modules_ionic_core_dist_esm_ion-route_4_entry_js"], {
    /***/
    54990:
    /*!****************************************************************!*\
      !*** ./node_modules/@ionic/core/dist/esm/ion-route_4.entry.js ***!
      \****************************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "ion_route": function ion_route() {
          return (
            /* binding */
            Route
          );
        },

        /* harmony export */
        "ion_route_redirect": function ion_route_redirect() {
          return (
            /* binding */
            RouteRedirect
          );
        },

        /* harmony export */
        "ion_router": function ion_router() {
          return (
            /* binding */
            Router
          );
        },

        /* harmony export */
        "ion_router_link": function ion_router_link() {
          return (
            /* binding */
            RouterLink
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */
      19369);
      /* harmony import */


      var _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./index-8e692445.js */
      91477);
      /* harmony import */


      var _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./helpers-3b390e48.js */
      83870);
      /* harmony import */


      var _ionic_global_c74e4951_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! ./ionic-global-c74e4951.js */
      45460);
      /* harmony import */


      var _theme_7670341c_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! ./theme-7670341c.js */
      31756);
      /*!
       * (C) Ionic http://ionicframework.com - MIT License
       */


      var Route = /*#__PURE__*/function () {
        function Route(hostRef) {
          _classCallCheck(this, Route);

          (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
          this.ionRouteDataChanged = (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteDataChanged", 7);
          /**
           * Relative path that needs to match in order for this route to apply.
           *
           * Accepts paths similar to expressjs so that you can define parameters
           * in the url /foo/:bar where bar would be available in incoming props.
           */

          this.url = '';
        }

        return _createClass(Route, [{
          key: "onUpdate",
          value: function onUpdate(newValue) {
            this.ionRouteDataChanged.emit(newValue);
          }
        }, {
          key: "onComponentProps",
          value: function onComponentProps(newValue, oldValue) {
            if (newValue === oldValue) {
              return;
            }

            var keys1 = newValue ? Object.keys(newValue) : [];
            var keys2 = oldValue ? Object.keys(oldValue) : [];

            if (keys1.length !== keys2.length) {
              this.onUpdate(newValue);
              return;
            }

            var _iterator = _createForOfIteratorHelper(keys1),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var key = _step.value;

                if (newValue[key] !== oldValue[key]) {
                  this.onUpdate(newValue);
                  return;
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        }, {
          key: "connectedCallback",
          value: function connectedCallback() {
            this.ionRouteDataChanged.emit();
          }
        }], [{
          key: "watchers",
          get: function get() {
            return {
              "url": ["onUpdate"],
              "component": ["onUpdate"],
              "componentProps": ["onComponentProps"]
            };
          }
        }]);
      }();

      var RouteRedirect = /*#__PURE__*/function () {
        function RouteRedirect(hostRef) {
          _classCallCheck(this, RouteRedirect);

          (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
          this.ionRouteRedirectChanged = (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteRedirectChanged", 7);
        }

        return _createClass(RouteRedirect, [{
          key: "propDidChange",
          value: function propDidChange() {
            this.ionRouteRedirectChanged.emit();
          }
        }, {
          key: "connectedCallback",
          value: function connectedCallback() {
            this.ionRouteRedirectChanged.emit();
          }
        }], [{
          key: "watchers",
          get: function get() {
            return {
              "from": ["propDidChange"],
              "to": ["propDidChange"]
            };
          }
        }]);
      }();

      var ROUTER_INTENT_NONE = 'root';
      var ROUTER_INTENT_FORWARD = 'forward';
      var ROUTER_INTENT_BACK = 'back';
      /** Join the non empty segments with "/". */

      var generatePath = function generatePath(segments) {
        var path = segments.filter(function (s) {
          return s.length > 0;
        }).join('/');
        return '/' + path;
      };

      var generateUrl = function generateUrl(segments, useHash, queryString) {
        var url = generatePath(segments);

        if (useHash) {
          url = '#' + url;
        }

        if (queryString !== undefined) {
          url += '?' + queryString;
        }

        return url;
      };

      var writeSegments = function writeSegments(history, root, useHash, segments, direction, state, queryString) {
        var url = generateUrl([].concat(_toConsumableArray(parsePath(root).segments), _toConsumableArray(segments)), useHash, queryString);

        if (direction === ROUTER_INTENT_FORWARD) {
          history.pushState(state, '', url);
        } else {
          history.replaceState(state, '', url);
        }
      };
      /**
       * Transforms a chain to a list of segments.
       *
       * Notes:
       * - parameter segments of the form :param are replaced with their value,
       * - null is returned when a value is missing for any parameter segment.
       */


      var chainToSegments = function chainToSegments(chain) {
        var segments = [];

        var _iterator2 = _createForOfIteratorHelper(chain),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var route = _step2.value;

            var _iterator3 = _createForOfIteratorHelper(route.segments),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var segment = _step3.value;

                if (segment[0] === ':') {
                  var param = route.params && route.params[segment.slice(1)];

                  if (!param) {
                    return null;
                  }

                  segments.push(param);
                } else if (segment !== '') {
                  segments.push(segment);
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return segments;
      };
      /**
       * Removes the prefix segments from the path segments.
       *
       * Return:
       * - null when the path segments do not start with the passed prefix,
       * - the path segments after the prefix otherwise.
       */


      var removePrefix = function removePrefix(prefix, segments) {
        if (prefix.length > segments.length) {
          return null;
        }

        if (prefix.length <= 1 && prefix[0] === '') {
          return segments;
        }

        for (var i = 0; i < prefix.length; i++) {
          if (prefix[i] !== segments[i]) {
            return null;
          }
        }

        if (segments.length === prefix.length) {
          return [''];
        }

        return segments.slice(prefix.length);
      };

      var readSegments = function readSegments(loc, root, useHash) {
        var prefix = parsePath(root).segments;
        var pathname = useHash ? loc.hash.slice(1) : loc.pathname;
        var segments = parsePath(pathname).segments;
        return removePrefix(prefix, segments);
      };
      /**
       * Parses the path to:
       * - segments an array of '/' separated parts,
       * - queryString (undefined when no query string).
       */


      var parsePath = function parsePath(path) {
        var segments = [''];
        var queryString;

        if (path != null) {
          var qsStart = path.indexOf('?');

          if (qsStart > -1) {
            queryString = path.substring(qsStart + 1);
            path = path.substring(0, qsStart);
          }

          segments = path.split('/').map(function (s) {
            return s.trim();
          }).filter(function (s) {
            return s.length > 0;
          });

          if (segments.length === 0) {
            segments = [''];
          }
        }

        return {
          segments: segments,
          queryString: queryString
        };
      };

      var printRoutes = function printRoutes(routes) {
        console.group("[ion-core] ROUTES[".concat(routes.length, "]"));

        var _iterator4 = _createForOfIteratorHelper(routes),
            _step4;

        try {
          var _loop = function _loop() {
            var chain = _step4.value;
            var segments = [];
            chain.forEach(function (r) {
              return segments.push.apply(segments, _toConsumableArray(r.segments));
            });
            var ids = chain.map(function (r) {
              return r.id;
            });
            console.debug("%c ".concat(generatePath(segments)), 'font-weight: bold; padding-left: 20px', '=>\t', "(".concat(ids.join(', '), ")"));
          };

          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        console.groupEnd();
      };

      var printRedirects = function printRedirects(redirects) {
        console.group("[ion-core] REDIRECTS[".concat(redirects.length, "]"));

        var _iterator5 = _createForOfIteratorHelper(redirects),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var redirect = _step5.value;

            if (redirect.to) {
              console.debug('FROM: ', "$c ".concat(generatePath(redirect.from)), 'font-weight: bold', ' TO: ', "$c ".concat(generatePath(redirect.to.segments)), 'font-weight: bold');
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        console.groupEnd();
      };
      /**
       * Activates the passed route chain.
       *
       * There must be exactly one outlet per route entry in the chain.
       *
       * The methods calls setRouteId on each of the outlet with the corresponding route entry in the chain.
       * setRouteId will create or select the view in the outlet.
       */


      var _writeNavState = /*#__PURE__*/function () {
        var _ref = (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function (root, chain, direction, index) {
          var changed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var animation = arguments.length > 5 ? arguments[5] : undefined;
          return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var outlet, route, result;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  // find next navigation outlet in the DOM
                  outlet = searchNavNode(root); // make sure we can continue interacting the DOM, otherwise abort

                  if (!(index >= chain.length || !outlet)) {
                    _context.next = 4;
                    break;
                  }

                  return _context.abrupt("return", changed);

                case 4:
                  _context.next = 6;
                  return new Promise(function (resolve) {
                    return (0, _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_2__.c)(outlet, resolve);
                  });

                case 6:
                  route = chain[index];
                  _context.next = 9;
                  return outlet.setRouteId(route.id, route.params, direction, animation);

                case 9:
                  result = _context.sent;

                  // if the outlet changed the page, reset navigation to neutral (no direction)
                  // this means nested outlets will not animate
                  if (result.changed) {
                    direction = ROUTER_INTENT_NONE;
                    changed = true;
                  } // recursively set nested outlets


                  _context.next = 13;
                  return _writeNavState(result.element, chain, direction, index + 1, changed, animation);

                case 13:
                  changed = _context.sent;

                  if (!result.markVisible) {
                    _context.next = 17;
                    break;
                  }

                  _context.next = 17;
                  return result.markVisible();

                case 17:
                  return _context.abrupt("return", changed);

                case 20:
                  _context.prev = 20;
                  _context.t0 = _context["catch"](0);
                  console.error(_context.t0);
                  return _context.abrupt("return", false);

                case 24:
                case "end":
                  return _context.stop();
              }
            }, _callee, null, [[0, 20]]);
          })();
        });

        return function writeNavState(_x, _x2, _x3, _x4) {
          return _ref.apply(this, arguments);
        };
      }();
      /**
       * Recursively walks the outlet in the DOM.
       *
       * The function returns a list of RouteID corresponding to each of the outlet and the last outlet without a RouteID.
       */


      var readNavState = /*#__PURE__*/function () {
        var _ref2 = (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(root) {
          var ids, outlet, node, id;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                ids = [];
                node = root; // eslint-disable-next-line no-cond-assign

              case 2:
                if (!(outlet = searchNavNode(node))) {
                  _context2.next = 15;
                  break;
                }

                _context2.next = 5;
                return outlet.getRouteId();

              case 5:
                id = _context2.sent;

                if (!id) {
                  _context2.next = 12;
                  break;
                }

                node = id.element;
                id.element = undefined;
                ids.push(id);
                _context2.next = 13;
                break;

              case 12:
                return _context2.abrupt("break", 15);

              case 13:
                _context2.next = 2;
                break;

              case 15:
                return _context2.abrupt("return", {
                  ids: ids,
                  outlet: outlet
                });

              case 16:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));

        return function readNavState(_x5) {
          return _ref2.apply(this, arguments);
        };
      }();

      var waitUntilNavNode = function waitUntilNavNode() {
        if (searchNavNode(document.body)) {
          return Promise.resolve();
        }

        return new Promise(function (resolve) {
          window.addEventListener('ionNavWillLoad', function () {
            return resolve();
          }, {
            once: true
          });
        });
      };
      /** Selector for all the outlets supported by the router. */


      var OUTLET_SELECTOR = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';

      var searchNavNode = function searchNavNode(root) {
        if (!root) {
          return undefined;
        }

        if (root.matches(OUTLET_SELECTOR)) {
          return root;
        }

        var outlet = root.querySelector(OUTLET_SELECTOR);
        return outlet !== null && outlet !== void 0 ? outlet : undefined;
      };
      /**
       * Returns whether the given redirect matches the given path segments.
       *
       * A redirect matches when the segments of the path and redirect.from are equal.
       * Note that segments are only checked until redirect.from contains a '*' which matches any path segment.
       * The path ['some', 'path', 'to', 'page'] matches both ['some', 'path', 'to', 'page'] and ['some', 'path', '*'].
       */


      var matchesRedirect = function matchesRedirect(segments, redirect) {
        var from = redirect.from,
            to = redirect.to;

        if (to === undefined) {
          return false;
        }

        if (from.length > segments.length) {
          return false;
        }

        for (var i = 0; i < from.length; i++) {
          var expected = from[i];

          if (expected === '*') {
            return true;
          }

          if (expected !== segments[i]) {
            return false;
          }
        }

        return from.length === segments.length;
      };
      /** Returns the first redirect matching the path segments or undefined when no match found. */


      var findRouteRedirect = function findRouteRedirect(segments, redirects) {
        return redirects.find(function (redirect) {
          return matchesRedirect(segments, redirect);
        });
      };

      var matchesIDs = function matchesIDs(ids, chain) {
        var len = Math.min(ids.length, chain.length);
        var score = 0;

        for (var i = 0; i < len; i++) {
          var routeId = ids[i];
          var routeChain = chain[i]; // Skip results where the route id does not match the chain at the same index

          if (routeId.id.toLowerCase() !== routeChain.id) {
            break;
          }

          if (routeId.params) {
            var routeIdParams = Object.keys(routeId.params); // Only compare routes with the chain that have the same number of parameters.

            if (routeIdParams.length === routeChain.segments.length) {
              // Maps the route's params into a path based on the path variable names,
              // to compare against the route chain format.
              //
              // Before:
              // ```ts
              // {
              //  params: {
              //    s1: 'a',
              //    s2: 'b'
              //  }
              // }
              // ```
              //
              // After:
              // ```ts
              // [':s1',':s2']
              // ```
              //
              var pathWithParams = routeIdParams.map(function (key) {
                return ":".concat(key);
              });

              for (var j = 0; j < pathWithParams.length; j++) {
                // Skip results where the path variable is not a match
                if (pathWithParams[j].toLowerCase() !== routeChain.segments[j]) {
                  break;
                } // Weight path matches for the same index higher.


                score++;
              }
            }
          } // Weight id matches


          score++;
        }

        return score;
      };
      /**
       * Matches the segments against the chain.
       *
       * Returns:
       * - null when there is no match,
       * - a chain with the params properties updated with the parameter segments on match.
       */


      var matchesSegments = function matchesSegments(segments, chain) {
        var inputSegments = new RouterSegments(segments);
        var matchesDefault = false;
        var allparams;

        for (var i = 0; i < chain.length; i++) {
          var chainSegments = chain[i].segments;

          if (chainSegments[0] === '') {
            matchesDefault = true;
          } else {
            var _iterator6 = _createForOfIteratorHelper(chainSegments),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var segment = _step6.value;
                var data = inputSegments.next(); // data param

                if (segment[0] === ':') {
                  if (data === '') {
                    return null;
                  }

                  allparams = allparams || [];
                  var params = allparams[i] || (allparams[i] = {});
                  params[segment.slice(1)] = data;
                } else if (data !== segment) {
                  return null;
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }

            matchesDefault = false;
          }
        }

        var matches = matchesDefault ? matchesDefault === (inputSegments.next() === '') : true;

        if (!matches) {
          return null;
        }

        if (allparams) {
          return chain.map(function (route, i) {
            return {
              id: route.id,
              segments: route.segments,
              params: mergeParams(route.params, allparams[i]),
              beforeEnter: route.beforeEnter,
              beforeLeave: route.beforeLeave
            };
          });
        }

        return chain;
      };
      /**
       * Merges the route parameter objects.
       * Returns undefined when both parameters are undefined.
       */


      var mergeParams = function mergeParams(a, b) {
        return a || b ? Object.assign(Object.assign({}, a), b) : undefined;
      };
      /**
       * Finds the best match for the ids in the chains.
       *
       * Returns the best match or null when no match is found.
       * When a chain is returned the parameters are updated from the RouteIDs.
       * That is they contain both the componentProps of the <ion-route> and the parameter segment.
       */


      var findChainForIDs = function findChainForIDs(ids, chains) {
        var match = null;
        var maxMatches = 0;

        var _iterator7 = _createForOfIteratorHelper(chains),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var chain = _step7.value;
            var score = matchesIDs(ids, chain);

            if (score > maxMatches) {
              match = chain;
              maxMatches = score;
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        if (match) {
          return match.map(function (route, i) {
            var _a;

            return {
              id: route.id,
              segments: route.segments,
              params: mergeParams(route.params, (_a = ids[i]) === null || _a === void 0 ? void 0 : _a.params)
            };
          });
        }

        return null;
      };
      /**
       * Finds the best match for the segments in the chains.
       *
       * Returns the best match or null when no match is found.
       * When a chain is returned the parameters are updated from the segments.
       * That is they contain both the componentProps of the <ion-route> and the parameter segments.
       */


      var findChainForSegments = function findChainForSegments(segments, chains) {
        var match = null;
        var bestScore = 0;

        var _iterator8 = _createForOfIteratorHelper(chains),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var chain = _step8.value;
            var matchedChain = matchesSegments(segments, chain);

            if (matchedChain !== null) {
              var score = computePriority(matchedChain);

              if (score > bestScore) {
                bestScore = score;
                match = matchedChain;
              }
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }

        return match;
      };
      /**
       * Computes the priority of a chain.
       *
       * Parameter segments are given a lower priority over fixed segments.
       *
       * Considering the following 2 chains matching the path /path/to/page:
       * - /path/to/:where
       * - /path/to/page
       *
       * The second one will be given a higher priority because "page" is a fixed segment (vs ":where", a parameter segment).
       */


      var computePriority = function computePriority(chain) {
        var score = 1;
        var level = 1;

        var _iterator9 = _createForOfIteratorHelper(chain),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var route = _step9.value;

            var _iterator10 = _createForOfIteratorHelper(route.segments),
                _step10;

            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var segment = _step10.value;

                if (segment[0] === ':') {
                  score += Math.pow(1, level);
                } else if (segment !== '') {
                  score += Math.pow(2, level);
                }

                level++;
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        return score;
      };

      var RouterSegments = /*#__PURE__*/function () {
        function RouterSegments(segments) {
          _classCallCheck(this, RouterSegments);

          this.segments = segments.slice();
        }

        return _createClass(RouterSegments, [{
          key: "next",
          value: function next() {
            if (this.segments.length > 0) {
              return this.segments.shift();
            }

            return '';
          }
        }]);
      }();

      var readProp = function readProp(el, prop) {
        if (prop in el) {
          return el[prop];
        }

        if (el.hasAttribute(prop)) {
          return el.getAttribute(prop);
        }

        return null;
      };
      /**
       * Extracts the redirects (that is <ion-route-redirect> elements inside the root).
       *
       * The redirects are returned as a list of RouteRedirect.
       */


      var readRedirects = function readRedirects(root) {
        return Array.from(root.children).filter(function (el) {
          return el.tagName === 'ION-ROUTE-REDIRECT';
        }).map(function (el) {
          var to = readProp(el, 'to');
          return {
            from: parsePath(readProp(el, 'from')).segments,
            to: to == null ? undefined : parsePath(to)
          };
        });
      };
      /**
       * Extracts all the routes (that is <ion-route> elements inside the root).
       *
       * The routes are returned as a list of chains - the flattened tree.
       */


      var readRoutes = function readRoutes(root) {
        return flattenRouterTree(_readRouteNodes(root));
      };
      /**
       * Reads the route nodes as a tree modeled after the DOM tree of <ion-route> elements.
       *
       * Note: routes without a component are ignored together with their children.
       */


      var _readRouteNodes = function readRouteNodes(node) {
        return Array.from(node.children).filter(function (el) {
          return el.tagName === 'ION-ROUTE' && el.component;
        }).map(function (el) {
          var component = readProp(el, 'component');
          return {
            segments: parsePath(readProp(el, 'url')).segments,
            id: component.toLowerCase(),
            params: el.componentProps,
            beforeLeave: el.beforeLeave,
            beforeEnter: el.beforeEnter,
            children: _readRouteNodes(el)
          };
        });
      };
      /**
       * Flattens a RouterTree in a list of chains.
       *
       * Each chain represents a path from the root node to a terminal node.
       */


      var flattenRouterTree = function flattenRouterTree(nodes) {
        var chains = [];

        var _iterator11 = _createForOfIteratorHelper(nodes),
            _step11;

        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var node = _step11.value;

            _flattenNode([], chains, node);
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }

        return chains;
      };
      /** Flattens a route node recursively and push each branch to the chains list. */


      var _flattenNode = function flattenNode(chain, chains, node) {
        chain = [].concat(_toConsumableArray(chain), [{
          id: node.id,
          segments: node.segments,
          params: node.params,
          beforeLeave: node.beforeLeave,
          beforeEnter: node.beforeEnter
        }]);

        if (node.children.length === 0) {
          chains.push(chain);
          return;
        }

        var _iterator12 = _createForOfIteratorHelper(node.children),
            _step12;

        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var child = _step12.value;

            _flattenNode(chain, chains, child);
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
      };

      var Router = /*#__PURE__*/function () {
        function Router(hostRef) {
          _classCallCheck(this, Router);

          (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
          this.ionRouteWillChange = (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteWillChange", 7);
          this.ionRouteDidChange = (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionRouteDidChange", 7);
          this.previousPath = null;
          this.busy = false;
          this.state = 0;
          this.lastState = 0;
          /**
           * The root path to use when matching URLs. By default, this is set to "/", but you can specify
           * an alternate prefix for all URL paths.
           */

          this.root = '/';
          /**
           * The router can work in two "modes":
           * - With hash: `/index.html#/path/to/page`
           * - Without hash: `/path/to/page`
           *
           * Using one or another might depend in the requirements of your app and/or where it's deployed.
           *
           * Usually "hash-less" navigation works better for SEO and it's more user friendly too, but it might
           * requires additional server-side configuration in order to properly work.
           *
           * On the other side hash-navigation is much easier to deploy, it even works over the file protocol.
           *
           * By default, this property is `true`, change to `false` to allow hash-less URLs.
           */

          this.useHash = true;
        }

        return _createClass(Router, [{
          key: "componentWillLoad",
          value: function componentWillLoad() {
            var _this = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
              var canProceed, redirect, path;
              return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return waitUntilNavNode();

                  case 2:
                    _context3.next = 4;
                    return _this.runGuards(_this.getSegments());

                  case 4:
                    canProceed = _context3.sent;

                    if (!(canProceed !== true)) {
                      _context3.next = 14;
                      break;
                    }

                    if (!(typeof canProceed === 'object')) {
                      _context3.next = 12;
                      break;
                    }

                    redirect = canProceed.redirect;
                    path = parsePath(redirect);

                    _this.setSegments(path.segments, ROUTER_INTENT_NONE, path.queryString);

                    _context3.next = 12;
                    return _this.writeNavStateRoot(path.segments, ROUTER_INTENT_NONE);

                  case 12:
                    _context3.next = 16;
                    break;

                  case 14:
                    _context3.next = 16;
                    return _this.onRoutesChanged();

                  case 16:
                  case "end":
                    return _context3.stop();
                }
              }, _callee3);
            }))();
          }
        }, {
          key: "componentDidLoad",
          value: function componentDidLoad() {
            window.addEventListener('ionRouteRedirectChanged', (0, _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_2__.q)(this.onRedirectChanged.bind(this), 10));
            window.addEventListener('ionRouteDataChanged', (0, _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_2__.q)(this.onRoutesChanged.bind(this), 100));
          }
        }, {
          key: "onPopState",
          value: function onPopState() {
            var _this2 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
              var direction, segments, canProceed;
              return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    direction = _this2.historyDirection();
                    segments = _this2.getSegments();
                    _context4.next = 4;
                    return _this2.runGuards(segments);

                  case 4:
                    canProceed = _context4.sent;

                    if (!(canProceed !== true)) {
                      _context4.next = 11;
                      break;
                    }

                    if (!(typeof canProceed === 'object')) {
                      _context4.next = 10;
                      break;
                    }

                    segments = parsePath(canProceed.redirect).segments;
                    _context4.next = 11;
                    break;

                  case 10:
                    return _context4.abrupt("return", false);

                  case 11:
                    return _context4.abrupt("return", _this2.writeNavStateRoot(segments, direction));

                  case 12:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }))();
          }
        }, {
          key: "onBackButton",
          value: function onBackButton(ev) {
            var _this12 = this;

            ev.detail.register(0, function (processNextHandler) {
              _this12.back();

              processNextHandler();
            });
          }
          /** @internal */

        }, {
          key: "canTransition",
          value: function canTransition() {
            var _this3 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
              var canProceed;
              return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return _this3.runGuards();

                  case 2:
                    canProceed = _context5.sent;

                    if (!(canProceed !== true)) {
                      _context5.next = 9;
                      break;
                    }

                    if (!(typeof canProceed === 'object')) {
                      _context5.next = 8;
                      break;
                    }

                    return _context5.abrupt("return", canProceed.redirect);

                  case 8:
                    return _context5.abrupt("return", false);

                  case 9:
                    return _context5.abrupt("return", true);

                  case 10:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5);
            }))();
          }
          /**
           * Navigate to the specified path.
           *
           * @param path The path to navigate to.
           * @param direction The direction of the animation. Defaults to `"forward"`.
           */

        }, {
          key: "push",
          value: function push(path) {
            var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'forward';
            var animation = arguments.length > 2 ? arguments[2] : undefined;

            var _this4 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
              var _a, currentPath, url, parsedPath, canProceed;

              return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    if (path.startsWith('.')) {
                      currentPath = (_a = _this4.previousPath) !== null && _a !== void 0 ? _a : '/'; // Convert currentPath to an URL by pre-pending a protocol and a host to resolve the relative path.

                      url = new URL(path, "https://host/".concat(currentPath));
                      path = url.pathname + url.search;
                    }

                    parsedPath = parsePath(path);
                    _context6.next = 4;
                    return _this4.runGuards(parsedPath.segments);

                  case 4:
                    canProceed = _context6.sent;

                    if (!(canProceed !== true)) {
                      _context6.next = 11;
                      break;
                    }

                    if (!(typeof canProceed === 'object')) {
                      _context6.next = 10;
                      break;
                    }

                    parsedPath = parsePath(canProceed.redirect);
                    _context6.next = 11;
                    break;

                  case 10:
                    return _context6.abrupt("return", false);

                  case 11:
                    _this4.setSegments(parsedPath.segments, direction, parsedPath.queryString);

                    return _context6.abrupt("return", _this4.writeNavStateRoot(parsedPath.segments, direction, animation));

                  case 13:
                  case "end":
                    return _context6.stop();
                }
              }, _callee6);
            }))();
          }
          /** Go back to previous page in the window.history. */

        }, {
          key: "back",
          value: function back() {
            window.history.back();
            return Promise.resolve(this.waitPromise);
          }
          /** @internal */

        }, {
          key: "printDebug",
          value: function printDebug() {
            var _this5 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
              return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                while (1) switch (_context7.prev = _context7.next) {
                  case 0:
                    printRoutes(readRoutes(_this5.el));
                    printRedirects(readRedirects(_this5.el));

                  case 2:
                  case "end":
                    return _context7.stop();
                }
              }, _callee7);
            }))();
          }
          /** @internal */

        }, {
          key: "navChanged",
          value: function navChanged(direction) {
            var _this6 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
              var _yield$readNavState, ids, outlet, routes, chain, segments;

              return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                while (1) switch (_context8.prev = _context8.next) {
                  case 0:
                    if (!_this6.busy) {
                      _context8.next = 3;
                      break;
                    }

                    console.warn('[ion-router] router is busy, navChanged was cancelled');
                    return _context8.abrupt("return", false);

                  case 3:
                    _context8.next = 5;
                    return readNavState(window.document.body);

                  case 5:
                    _yield$readNavState = _context8.sent;
                    ids = _yield$readNavState.ids;
                    outlet = _yield$readNavState.outlet;
                    routes = readRoutes(_this6.el);
                    chain = findChainForIDs(ids, routes);

                    if (chain) {
                      _context8.next = 13;
                      break;
                    }

                    console.warn('[ion-router] no matching URL for ', ids.map(function (i) {
                      return i.id;
                    }));
                    return _context8.abrupt("return", false);

                  case 13:
                    segments = chainToSegments(chain);

                    if (segments) {
                      _context8.next = 17;
                      break;
                    }

                    console.warn('[ion-router] router could not match path because some required param is missing');
                    return _context8.abrupt("return", false);

                  case 17:
                    _this6.setSegments(segments, direction);

                    _context8.next = 20;
                    return _this6.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, segments, null, ids.length);

                  case 20:
                    return _context8.abrupt("return", true);

                  case 21:
                  case "end":
                    return _context8.stop();
                }
              }, _callee8);
            }))();
          }
          /** This handler gets called when a `ion-route-redirect` component is added to the DOM or if the from or to property of such node changes. */

        }, {
          key: "onRedirectChanged",
          value: function onRedirectChanged() {
            var segments = this.getSegments();

            if (segments && findRouteRedirect(segments, readRedirects(this.el))) {
              this.writeNavStateRoot(segments, ROUTER_INTENT_NONE);
            }
          }
          /** This handler gets called when a `ion-route` component is added to the DOM or if the from or to property of such node changes. */

        }, {
          key: "onRoutesChanged",
          value: function onRoutesChanged() {
            return this.writeNavStateRoot(this.getSegments(), ROUTER_INTENT_NONE);
          }
        }, {
          key: "historyDirection",
          value: function historyDirection() {
            var _a;

            var win = window;

            if (win.history.state === null) {
              this.state++;
              win.history.replaceState(this.state, win.document.title, (_a = win.document.location) === null || _a === void 0 ? void 0 : _a.href);
            }

            var state = win.history.state;
            var lastState = this.lastState;
            this.lastState = state;

            if (state > lastState || state >= lastState && lastState > 0) {
              return ROUTER_INTENT_FORWARD;
            }

            if (state < lastState) {
              return ROUTER_INTENT_BACK;
            }

            return ROUTER_INTENT_NONE;
          }
        }, {
          key: "writeNavStateRoot",
          value: function writeNavStateRoot(segments, direction, animation) {
            var _this7 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
              var redirects, redirect, redirectFrom, _redirect$to, toSegments, queryString, routes, chain;

              return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    if (segments) {
                      _context9.next = 3;
                      break;
                    }

                    console.error('[ion-router] URL is not part of the routing set');
                    return _context9.abrupt("return", false);

                  case 3:
                    // lookup redirect rule
                    redirects = readRedirects(_this7.el);
                    redirect = findRouteRedirect(segments, redirects);
                    redirectFrom = null;

                    if (redirect) {
                      _redirect$to = redirect.to, toSegments = _redirect$to.segments, queryString = _redirect$to.queryString;

                      _this7.setSegments(toSegments, direction, queryString);

                      redirectFrom = redirect.from;
                      segments = toSegments;
                    } // lookup route chain


                    routes = readRoutes(_this7.el);
                    chain = findChainForSegments(segments, routes);

                    if (chain) {
                      _context9.next = 12;
                      break;
                    }

                    console.error('[ion-router] the path does not match any route');
                    return _context9.abrupt("return", false);

                  case 12:
                    return _context9.abrupt("return", _this7.safeWriteNavState(document.body, chain, direction, segments, redirectFrom, 0, animation));

                  case 13:
                  case "end":
                    return _context9.stop();
                }
              }, _callee9);
            }))();
          }
        }, {
          key: "safeWriteNavState",
          value: function safeWriteNavState(node, chain, direction, segments, redirectFrom) {
            var index = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
            var animation = arguments.length > 6 ? arguments[6] : undefined;

            var _this8 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
              var unlock, changed;
              return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                while (1) switch (_context10.prev = _context10.next) {
                  case 0:
                    _context10.next = 2;
                    return _this8.lock();

                  case 2:
                    unlock = _context10.sent;
                    changed = false;
                    _context10.prev = 4;
                    _context10.next = 7;
                    return _this8.writeNavState(node, chain, direction, segments, redirectFrom, index, animation);

                  case 7:
                    changed = _context10.sent;
                    _context10.next = 13;
                    break;

                  case 10:
                    _context10.prev = 10;
                    _context10.t0 = _context10["catch"](4);
                    console.error(_context10.t0);

                  case 13:
                    unlock();
                    return _context10.abrupt("return", changed);

                  case 15:
                  case "end":
                    return _context10.stop();
                }
              }, _callee10, null, [[4, 10]]);
            }))();
          }
        }, {
          key: "lock",
          value: function lock() {
            var _this9 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
              var p, resolve;
              return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                while (1) switch (_context11.prev = _context11.next) {
                  case 0:
                    p = _this9.waitPromise;
                    _this9.waitPromise = new Promise(function (r) {
                      return resolve = r;
                    });

                    if (!(p !== undefined)) {
                      _context11.next = 5;
                      break;
                    }

                    _context11.next = 5;
                    return p;

                  case 5:
                    return _context11.abrupt("return", resolve);

                  case 6:
                  case "end":
                    return _context11.stop();
                }
              }, _callee11);
            }))();
          }
          /**
           * Executes the beforeLeave hook of the source route and the beforeEnter hook of the target route if they exist.
           *
           * When the beforeLeave hook does not return true (to allow navigating) then that value is returned early and the beforeEnter is executed.
           * Otherwise the beforeEnterHook hook of the target route is executed.
           */

        }, {
          key: "runGuards",
          value: function runGuards() {
            var to = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSegments();
            var from = arguments.length > 1 ? arguments[1] : undefined;

            var _this10 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
              var routes, fromChain, beforeLeaveHook, canLeave, toChain, beforeEnterHook;
              return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                while (1) switch (_context12.prev = _context12.next) {
                  case 0:
                    if (from === undefined) {
                      from = parsePath(_this10.previousPath).segments;
                    }

                    if (!(!to || !from)) {
                      _context12.next = 3;
                      break;
                    }

                    return _context12.abrupt("return", true);

                  case 3:
                    routes = readRoutes(_this10.el);
                    fromChain = findChainForSegments(from, routes);
                    beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;

                    if (!beforeLeaveHook) {
                      _context12.next = 12;
                      break;
                    }

                    _context12.next = 9;
                    return beforeLeaveHook();

                  case 9:
                    _context12.t0 = _context12.sent;
                    _context12.next = 13;
                    break;

                  case 12:
                    _context12.t0 = true;

                  case 13:
                    canLeave = _context12.t0;

                    if (!(canLeave === false || typeof canLeave === 'object')) {
                      _context12.next = 16;
                      break;
                    }

                    return _context12.abrupt("return", canLeave);

                  case 16:
                    toChain = findChainForSegments(to, routes);
                    beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;
                    return _context12.abrupt("return", beforeEnterHook ? beforeEnterHook() : true);

                  case 19:
                  case "end":
                    return _context12.stop();
                }
              }, _callee12);
            }))();
          }
        }, {
          key: "writeNavState",
          value: function writeNavState(node, chain, direction, segments, redirectFrom) {
            var index = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
            var animation = arguments.length > 6 ? arguments[6] : undefined;

            var _this11 = this;

            return (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
              var routeEvent, changed;
              return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                while (1) switch (_context13.prev = _context13.next) {
                  case 0:
                    if (!_this11.busy) {
                      _context13.next = 3;
                      break;
                    }

                    console.warn('[ion-router] router is busy, transition was cancelled');
                    return _context13.abrupt("return", false);

                  case 3:
                    _this11.busy = true; // generate route event and emit will change

                    routeEvent = _this11.routeChangeEvent(segments, redirectFrom);

                    if (routeEvent) {
                      _this11.ionRouteWillChange.emit(routeEvent);
                    }

                    _context13.next = 8;
                    return _writeNavState(node, chain, direction, index, false, animation);

                  case 8:
                    changed = _context13.sent;
                    _this11.busy = false; // emit did change

                    if (routeEvent) {
                      _this11.ionRouteDidChange.emit(routeEvent);
                    }

                    return _context13.abrupt("return", changed);

                  case 12:
                  case "end":
                    return _context13.stop();
                }
              }, _callee13);
            }))();
          }
        }, {
          key: "setSegments",
          value: function setSegments(segments, direction, queryString) {
            this.state++;
            writeSegments(window.history, this.root, this.useHash, segments, direction, this.state, queryString);
          }
        }, {
          key: "getSegments",
          value: function getSegments() {
            return readSegments(window.location, this.root, this.useHash);
          }
        }, {
          key: "routeChangeEvent",
          value: function routeChangeEvent(toSegments, redirectFromSegments) {
            var from = this.previousPath;
            var to = generatePath(toSegments);
            this.previousPath = to;

            if (to === from) {
              return null;
            }

            var redirectedFrom = redirectFromSegments ? generatePath(redirectFromSegments) : null;
            return {
              from: from,
              redirectedFrom: redirectedFrom,
              to: to
            };
          }
        }, {
          key: "el",
          get: function get() {
            return (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.i)(this);
          }
        }]);
      }();

      var routerLinkCss = ":host{--background:transparent;--color:var(--ion-color-primary, #3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}";

      var RouterLink = /*#__PURE__*/function () {
        function RouterLink(hostRef) {
          var _this13 = this;

          _classCallCheck(this, RouterLink);

          (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
          /**
           * When using a router, it specifies the transition direction when navigating to
           * another page using `href`.
           */

          this.routerDirection = 'forward';

          this.onClick = function (ev) {
            (0, _theme_7670341c_js__WEBPACK_IMPORTED_MODULE_4__.o)(_this13.href, ev, _this13.routerDirection, _this13.routerAnimation);
          };
        }

        return _createClass(RouterLink, [{
          key: "render",
          value: function render() {
            var mode = (0, _ionic_global_c74e4951_js__WEBPACK_IMPORTED_MODULE_3__.b)(this);
            var attrs = {
              href: this.href,
              rel: this.rel,
              target: this.target
            };
            return (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.h)(_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.H, {
              onClick: this.onClick,
              "class": (0, _theme_7670341c_js__WEBPACK_IMPORTED_MODULE_4__.c)(this.color, _defineProperty(_defineProperty({}, mode, true), 'ion-activatable', true))
            }, (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.h)("a", Object.assign({}, attrs), (0, _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", null)));
          }
        }]);
      }();

      RouterLink.style = routerLinkCss;
      /***/
    },

    /***/
    31756:
    /*!*************************************************************!*\
      !*** ./node_modules/@ionic/core/dist/esm/theme-7670341c.js ***!
      \*************************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "c": function c() {
          return (
            /* binding */
            createColorClasses
          );
        },

        /* harmony export */
        "g": function g() {
          return (
            /* binding */
            getClassMap
          );
        },

        /* harmony export */
        "h": function h() {
          return (
            /* binding */
            hostContext
          );
        },

        /* harmony export */
        "o": function o() {
          return (
            /* binding */
            openURL
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */
      19369);
      /*!
       * (C) Ionic http://ionicframework.com - MIT License
       */


      var hostContext = function hostContext(selector, el) {
        return el.closest(selector) !== null;
      };
      /**
       * Create the mode and color classes for the component based on the classes passed in
       */


      var createColorClasses = function createColorClasses(color, cssClassMap) {
        return typeof color === 'string' && color.length > 0 ? Object.assign(_defineProperty({
          'ion-color': true
        }, "ion-color-".concat(color), true), cssClassMap) : cssClassMap;
      };

      var getClassList = function getClassList(classes) {
        if (classes !== undefined) {
          var array = Array.isArray(classes) ? classes : classes.split(' ');
          return array.filter(function (c) {
            return c != null;
          }).map(function (c) {
            return c.trim();
          }).filter(function (c) {
            return c !== '';
          });
        }

        return [];
      };

      var getClassMap = function getClassMap(classes) {
        var map = {};
        getClassList(classes).forEach(function (c) {
          return map[c] = true;
        });
        return map;
      };

      var SCHEME = /^[a-z][a-z0-9+\-.]*:/;

      var openURL = /*#__PURE__*/function () {
        var _ref = (0, _Users_tucarmd_DATA_PROJECTS_proscan_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(url, ev, direction, animation) {
          var router;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                if (!(url != null && url[0] !== '#' && !SCHEME.test(url))) {
                  _context14.next = 5;
                  break;
                }

                router = document.querySelector('ion-router');

                if (!router) {
                  _context14.next = 5;
                  break;
                }

                if (ev != null) {
                  ev.preventDefault();
                }

                return _context14.abrupt("return", router.push(url, direction, animation));

              case 5:
                return _context14.abrupt("return", false);

              case 6:
              case "end":
                return _context14.stop();
            }
          }, _callee14);
        }));

        return function openURL(_x, _x2, _x3, _x4) {
          return _ref.apply(this, arguments);
        };
      }();
      /***/

    }
  }]);
})();
//# sourceMappingURL=node_modules_ionic_core_dist_esm_ion-route_4_entry_js-es5.js.map