(function () {
  "use strict";

  (self["webpackChunkcom_carmd_proscan2"] = self["webpackChunkcom_carmd_proscan2"] || []).push([["node_modules_ionic_core_dist_esm_index-2061d5f6_js"], {
    /***/
    85226:
    /*!*************************************************************!*\
      !*** ./node_modules/@ionic/core/dist/esm/index-2061d5f6.js ***!
      \*************************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "startTapClick": function startTapClick() {
          return (
            /* binding */
            _startTapClick
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./helpers-3b390e48.js */
      83870);
      /*!
       * (C) Ionic http://ionicframework.com - MIT License
       */


      var _startTapClick = function _startTapClick(config) {
        var lastTouch = -MOUSE_WAIT * 10;
        var lastActivated = 0;
        var activatableEle;
        var activeRipple;
        var activeDefer;
        var useRippleEffect = config.getBoolean('animated', true) && config.getBoolean('rippleEffect', true);
        var clearDefers = new WeakMap(); // Touch Events

        var onTouchStart = function onTouchStart(ev) {
          lastTouch = (0, _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_0__.u)(ev);
          pointerDown(ev);
        };

        var onTouchEnd = function onTouchEnd(ev) {
          lastTouch = (0, _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_0__.u)(ev);
          pointerUp(ev);
        };

        var onMouseDown = function onMouseDown(ev) {
          // Ignore right clicks
          if (ev.button === 2) {
            return;
          }

          var t = (0, _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_0__.u)(ev) - MOUSE_WAIT;

          if (lastTouch < t) {
            pointerDown(ev);
          }
        };

        var onMouseUp = function onMouseUp(ev) {
          var t = (0, _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_0__.u)(ev) - MOUSE_WAIT;

          if (lastTouch < t) {
            pointerUp(ev);
          }
        };

        var cancelActive = function cancelActive() {
          if (activeDefer) clearTimeout(activeDefer);
          activeDefer = undefined;

          if (activatableEle) {
            removeActivated(false);
            activatableEle = undefined;
          }
        };

        var pointerDown = function pointerDown(ev) {
          if (activatableEle) {
            return;
          }

          setActivatedElement(getActivatableTarget(ev), ev);
        };

        var pointerUp = function pointerUp(ev) {
          setActivatedElement(undefined, ev);
        };

        var setActivatedElement = function setActivatedElement(el, ev) {
          // do nothing
          if (el && el === activatableEle) {
            return;
          }

          if (activeDefer) clearTimeout(activeDefer);
          activeDefer = undefined;

          var _ref = (0, _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_0__.p)(ev),
              x = _ref.x,
              y = _ref.y; // deactivate selected


          if (activatableEle) {
            if (clearDefers.has(activatableEle)) {
              throw new Error('internal error');
            }

            if (!activatableEle.classList.contains(ACTIVATED)) {
              addActivated(activatableEle, x, y);
            }

            removeActivated(true);
          } // activate


          if (el) {
            var deferId = clearDefers.get(el);

            if (deferId) {
              clearTimeout(deferId);
              clearDefers["delete"](el);
            }

            el.classList.remove(ACTIVATED);

            var callback = function callback() {
              addActivated(el, x, y);
              activeDefer = undefined;
            };

            if (isInstant(el)) {
              callback();
            } else {
              activeDefer = setTimeout(callback, ADD_ACTIVATED_DEFERS);
            }
          }

          activatableEle = el;
        };

        var addActivated = function addActivated(el, x, y) {
          lastActivated = Date.now();
          el.classList.add(ACTIVATED);
          if (!useRippleEffect) return;
          var rippleEffect = getRippleEffect(el);

          if (rippleEffect !== null) {
            removeRipple();
            activeRipple = rippleEffect.addRipple(x, y);
          }
        };

        var removeRipple = function removeRipple() {
          if (activeRipple !== undefined) {
            activeRipple.then(function (remove) {
              return remove();
            });
            activeRipple = undefined;
          }
        };

        var removeActivated = function removeActivated(smooth) {
          removeRipple();
          var active = activatableEle;

          if (!active) {
            return;
          }

          var time = CLEAR_STATE_DEFERS - Date.now() + lastActivated;

          if (smooth && time > 0 && !isInstant(active)) {
            var deferId = setTimeout(function () {
              active.classList.remove(ACTIVATED);
              clearDefers["delete"](active);
            }, CLEAR_STATE_DEFERS);
            clearDefers.set(active, deferId);
          } else {
            active.classList.remove(ACTIVATED);
          }
        };

        var doc = document;
        doc.addEventListener('ionGestureCaptured', cancelActive);
        doc.addEventListener('touchstart', onTouchStart, true);
        doc.addEventListener('touchcancel', onTouchEnd, true);
        doc.addEventListener('touchend', onTouchEnd, true);
        /**
         * Tap click effects such as the ripple effect should
         * not happen when scrolling. For example, if a user scrolls
         * the page but also happens to do a touchstart on a button
         * as part of the scroll, the ripple effect should not
         * be dispatched. The ripple effect should only happen
         * if the button is activated and the page is not scrolling.
         *
         * pointercancel is dispatched on a gesture when scrolling
         * starts, so this lets us avoid having to listen for
         * ion-content's scroll events.
         */

        doc.addEventListener('pointercancel', cancelActive, true);
        doc.addEventListener('mousedown', onMouseDown, true);
        doc.addEventListener('mouseup', onMouseUp, true);
      }; // TODO(FW-2832): type


      var getActivatableTarget = function getActivatableTarget(ev) {
        if (ev.composedPath !== undefined) {
          /**
           * composedPath returns EventTarget[]. However,
           * objects other than Element can be targets too.
           * For example, AudioContext can be a target. In this
           * case, we know that the event is a UIEvent so we
           * can assume that the path will contain either Element
           * or ShadowRoot.
           */
          var path = ev.composedPath();

          for (var i = 0; i < path.length - 2; i++) {
            var el = path[i];

            if (!(el instanceof ShadowRoot) && el.classList.contains('ion-activatable')) {
              return el;
            }
          }
        } else {
          return ev.target.closest('.ion-activatable');
        }
      };

      var isInstant = function isInstant(el) {
        return el.classList.contains('ion-activatable-instant');
      };

      var getRippleEffect = function getRippleEffect(el) {
        if (el.shadowRoot) {
          var ripple = el.shadowRoot.querySelector('ion-ripple-effect');

          if (ripple) {
            return ripple;
          }
        }

        return el.querySelector('ion-ripple-effect');
      };

      var ACTIVATED = 'ion-activated';
      var ADD_ACTIVATED_DEFERS = 200;
      var CLEAR_STATE_DEFERS = 200;
      var MOUSE_WAIT = 2500;
      /***/
    }
  }]);
})();
//# sourceMappingURL=node_modules_ionic_core_dist_esm_index-2061d5f6_js-es5.js.map